<?php

// ВСТРОЕННЫЕ КЛАССЫ И ИНТЕРФЕЙСЫ
/*ВСТРОЕННЫЕ КЛАССЫ И ИНТЕРФЕЙСЫ
PHP содержит некоторое количество встроенных классов и интерфейсов.
На самом деле, их довольно много, но мы рассмотрим один - ArrayAccess,
чтобы дать общее понимание, как это работает и почему.
Итак, иногда действительно неплохо было бы иметь возможность
обращаться с объектами, как... с массивами. )
Например, мы можем захотеть написать свою "обёртку" над сессиями, но
работать с ней, как с массивом, т.е., по сути, как и раньше, но расширяя
возможности самого массива объектными "фишками".*/





/*ЧТО ТАКОЕ ARRAYACCESS?
ArrayAccess - это простой встроенный интерфейс*/
interface ArrayAccess {
  //проверяет, существует ли смещение
  abstract public offsetExists ( mixed $offset )
  //получает значение с индексом
  abstract public offsetGet ( mixed $offset )
  //задает значение с соответствующим индексом
  abstract public offsetSet ( mixed $offset , mixed $value
  //удаляет значение с соответствующим индексом
  abstract public offsetUnset ( mixed $offset )
}






/*КАК ЭТО РАБОТАЕТ?
По сути, при попытке обратиться к объекту, как к массиву - PHP будет
смотреть, существуют ли соответствующие методы.
— Нужно получить значение? Ну-ка, вызовем offsetGet.
— Есть ли вообще значение, куда сдвигаться? Проверим с помощью
offsetExists
От нас требуется только реализовать соответствующие методы. В чем
профит? Ну, иногда так бывает привычней и удобней (мы при этом можем
работать с объектом, как с объектом). Плюс, например, мы можем вообще
запретить удалять значения из нашего массива-объекта.*/




// ARRAYACCESS
  class TestClass implements \ArrayAccess //в глобальном пространстве {
  private $data = ['test', 'test2', 'test3'];
  public function offsetSet($index, $value) {
    if (is_null($index)) {
      $this->data[] = $value; //добавление значения без } else {
      $this->data[$index] = $value;
    }
  }
}



// ARRAYACCESS (Ч.2)
class TestClass implements \ArrayAccess //в глобальном пространстве 
{
  public function offsetExists($index) {
    return isset($this->data[$index]);
  }

  public function offsetUnset($index) {
    unset($this->data[$index]);
  }

  public function offsetGet($offset) {
    return isset($this->data[$index]) ? $this->data[$index]);
  }
}




// ARRAYACCESS (Ч.3)
// Работать с этим можно будет примерно так:
$test = new TestClass();
$test[] = 'Новый элемент массива';
$test[] = 'Еще новый элемент массива';
echo $test[1]; //выведет test2
isset($test[1]); //true
unset($test[1]);
isset($test[1]); //false





/*ARRAYACCESS (Ч.4)
При этом мы можем определять иную хитрую логику внутри методов,
которую захотим. Можем ничего не делать на unset. Можем дальше
пользоваться всеми прелестями объектов (создать иные методы и
обрщаться к ним напрямую)
По большому счёту это просто небольшой лайфхак. Например, мы можем
подобным образом делать работу с сессиями, при этом инициализируя
отложенно сессию, когда это будет нужно.*/




/*ЕЩЕ О ВСТРОЕННЫХ КЛАССАХ И
ИНТЕРФЕЙСАХ
Полный список - http://php.net/manual/ru/reserved.interfaces.php
Также, рекомендую обратить внимание на
http://php.net/manual/ru/class.reflectionclass.php - в крупных проектах с
хитрыми связями бывает полезно.
По большому счёту, это просто ещё немного магии языка PHP, которые
расширяют возможности его использования. Но жить и без этого вполне
себе можно (и даже нужно).*/
