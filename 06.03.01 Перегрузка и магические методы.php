<?php

//ПЕРЕГРУЗКА И МАГИЧЕСКИЕ МЕТОДЫ

/*ПЕРЕГРУЗКИ В PHP НЕ СУЩЕСТВУЕТ!
Вообще, понятие перегрузки означает несколько иное в других языках
программирования.
По сути, перегрузка - это возможность объявить два разных метода даже в
рамках одного класса, с одним названием, но разным количеством
аргументов. И в зависимости от количества аргументов будет вызываться
тот или иной метод.*/

/*ПЕРЕГРУЗКИ В PHP НЕ СУЩЕСТВУЕТ! (Ч.2)*/
class TestClass
{
  public function testMethod($a) { // тут одно поведение }
  public function testMethod($a, $b, $c) { // тут другое поведение 
  //но так в PHP делать НЕЛЬЗЯ
}
/*Вместо этого, перегрузка в PHP подразумевает возможность
динамически создавать и работать с недоступными свойствами и
методами.*/

/*ЧТО ЗНАЧИТ С НЕДОСТУПНЫМИ?
1. Защищенные или приватные свойства и методы (да, да, да)
2. Несуществующие свойства и методы, которые мы вообще не создавали
Вообще, в PHP можно так:*/
class TestClass { } //пустой класс без свойств
$test = new TestClass();
$test->a = 100; //динамическое создание и присваивание значения 
echo $test->a; // обращение к динамическому свойству

/*ЗАЧЕМ ЭТО ВСЁ?
На самом деле, целесообразность и зачем это всё, проще объяснить, когда
будет понятно, о чём именно речь и как этим пользоваться.
Итак, помните, мы говорили, что в PHP есть несколько магических методов,
которые вызываются, если происходит определенное событие?
Один из них - это метод __construct(); Событие - момент создания объекта
Все магические методы должны быть объявлены, как public.*/



// НЕМНООГО МАГИИ ДЛЯ СВОЙСТВ
/*Для свойств, PHP под перегрузкой подразумевает работу со следующими методами
1. __get($property);  - вызывается при обращении к недоступному свойству
2. __set($property, $value); - вызывается при попытке дать значение недоступному свойству
3. __isset($property); - вызывается при вызове isset() на недоступном свойстве
4. __unset($property); - вызове вызывается при вызове unset() на недоступном свойстве*/


/*__GET($PROPERTY)
С помощью данного метода мы можем разрешить обращаться к
недоступному свойству*/
class TestClass 
{
  public function __get($property) // $property
  {
    echo 'Обратились к недоступному свойству - ' . $property
  }
}
$test = new TestClass();
echo $test->a; //аналогично вызову $test->__get('a');
echo $test->lalala; //аналогично вызову $test->__get('lalala');



// __GET($PROPERTY) (Ч.2)
class TestClass {
  private $privateProperty;
  protected $protectedProperty;
  public function __get($property) // $property
  {
    echo 'Обратились к недоступному свойству - ' . $property
  }
}
$test = new TestClass();
echo $test->privateProperty; //аналогично вызову $test->__get('
echo $test->protectedProperty; //аналогично вызову $test->__get('1



// __GET($PROPERTY) (Ч.3)
class TestClass {
  private $privateProperty = 10;
  protected $protectedProperty;

  public function __get($property) // $property
  {
    // лайфхак - так мы открываем доступ к обращению к приватным 
    if (isset($this->$property))
    return $this->$property);
  }
}
$test = new TestClass();
echo $test->privateProperty; //выведет 10 (!!!)


/*__GET($PROPERTY) (Ч.4)
К вопросу зачем нам открывать доступ к приватным и защищенным
свойствам.
На самом деле, так делать не надо, иначе мы теряем все преимущества
областей видимости и можем столкнуться с неожидаемым поведением.
Но при этом, это даёт нам возможность полного контроля доступа к
свойствам, т.е. делает работу с объектами более гибкой.*/


// __GET($PROPERTY) (Ч.5)
class TestClass {
  public $property = 10;

  public function __get($property) // $property - строка-название 
  { 
    // лайфхак - так мы открываем доступ к обращению к приватным if (isset($this->$property))
    echo 'Вызвано недоступное свойство';
  }
}
$test = new TestClass();
echo $test->property; //для public - __get не вызывается!



/*__GET($PROPERTY) (Ч.6)
Мини-резюме по __get
1. Единственный аргумент содержит название недоступного свойства в
виде строки
2. Должен быть объявлен, как public
3. Вызывается при событии: обращение к недоступному свойству
4. Не вызывается, для публичных свойств класса
5. Вызывается для private и protected
6. Может содержать внутри любую логику для разных свойств*/



/*__SET($NAME, $VALUE)
__set вызывает при присвоении значения недоступному свойству*/
class TestClass {
  private $privateProperty = 10;
  // $name - строка-название свойства, $value - значение для public function __set($name, $value)
  { // запретили менять значени недоступных свойств
    return 'Ошибка - попытка присвоения значения недоступному';
  }
}
$test = new TestClass();
$test->privateProperty = 20; // == __set('privateProperty', 20)
$test->asdasd = 'lalala'; // == ___set('asdasd', 'lalala');



// __SET($NAME, $VALUE) (Ч.2)
// И да, таким образом мы можем разрешить менять приватные свойства
class TestClass {
  private $privateProperty = 10;
  public function __set($name, $value);
  {
    $this->$name = $value;
  }
}
$test = new TestClass();
$test->privateProperty = 20; // == __set('privateProperty', 20)
echo $test->privateProperty; // == 20, мы поменяли значение





// __SET($NAME, $VALUE) (Ч.3)
// __set ведет себя аналогично __get для существующих public свойств
class TestClass {
  public $publicProperty = 10;
  // $name - строка-название свойства, $value - значение для public function __set($name, $value)
  { // запретили менять значени недоступных свойств
    return 'Ошибка - попытка присвоения значения недоступному';
  }
}
$test = new TestClass();
$test->publicProperty = 10; //__set не вызывается!

/*__SET($NAME, $VALUE) (Ч.4)
Таким образом мы можем, например, разрешать доступ только к
приватным переменным, или создавать динамические свойства, запрешая
доступ к существующим, если они приватные или защищенные.
Еще одним способом применения может быть создание автоматических
геттеров и сеттеров*/







// АВТОМАТИЧЕСКИЕ ГЕТТЕРЫ И СЕТТЕРЫ
class TestClass {
  private $data = [];
  public function __set($name, $value)
  {
    $this->data[$name] = $value;
  }
  public function __get($name, $value)
  {
    if (isset($this->data['name']))
    return $this->data[$name];
  }
}



// __SET($NAME, $VALUE) (Ч.5)
// Мини-резюме
/*1. $name - строка , название свойства, $value - значение, которое нужно
присвоить
2. Должен быть объявлен, как public
3. Вызывается при событии: присвоение значения недоступному свойству
4. Не вызывается, для публичных свойств класса
5. Вызывается для private и protected
6. Может содержать внутри любую логику для разных свойств*/







/*__ISSET($PROPERTY)
__isset срабатывает при вызове isset не несуществующем свойстве*/
class TestClass {
protected $property = 10;
  // $property - строка-название свойства
  public function __isset($property)
  {
    return 'Ошибка - недоступное свойство';
  }
}
$test = new TestClass();
isset($test->property); // ошибка


// __ISSET($PROPERTY) (Ч.2)
// __isset также не вызовется для public свойств
class TestClass {
  public $property = 10;
  // $property - строка-название свойства
  public function __isset($property)
  {
    return 'Ошибка - недоступное свойство';
  }
}
$test = new TestClass();
isset($test->property); // true - нет ошибки



/*__UNSET($PROPERTY)
__unset вызывается при попытке удалить свойство*/
class TestClass {
  public $property = 10;
  // $property - строка-название свойства
  public function __unset($property)
  {
    return 'Ошибка - наши свойства нельзя удалять';
  }
}
$test = new TestClass();
unset($test->property); // ошибка


// __UNSET($PROPERTY) (Ч.2)
// А вот public - можно
class TestClass {
  public $property = 10;
  // $property - строка-название свойства
  public function __unset($property)
  {
    return 'Ошибка - наши свойства нельзя удалять';
  }
}
$test = new TestClass();
unset($test->property); // нет ошибки





/*__ISSET($NAME) И __UNSET($NAME)
Мини-резюме
1. $name - строка , название свойства
2. Должны быть объявлен, как public
3. Вызывается при событии: проверка свойства на существование (__isset)
либо удаление свойства (__unset)
4. Не вызывается, для публичных свойств класса
5. Вызывается для private и protected
6. Может содержать внутри любую логику для разных свойств*/



/*__ISSET($NAME) И __UNSET($NAME) (Ч.2)
Например, мы можем захотеть, чтобы ни одно наше свойство нельзя было
заансетить.
В этом случае можно объявить все свойства приватными или
защищенными, прописать соответствующую ошибку в __unset, а в __get и
__set прописать к каким свойствам можно обращаться
Разберем это в коде, а потом перейдём к методам.*/


/*О МЕТОДАХ
Помимо вызова недоступных свойств мы также можем полностью
контроллировать и обрабатывать вызов недоступных или
несуществующих методов. Для этого используются
1. __сall - для вызова недоступного метода (в контексте объекта)
2. __callStatic - для вызова недоступного метода (в контексте класса)
Почти всё аналогично работе со свойствами, поэтому рассмотрим их
кратко.*/



/*__CALL($NAME, $ARGUMENTS)
__call вызывается для недоступных методов, первый аргумент - строка,
название метода, а второй - массив аргументов*/
class TestClass {
  public function __call($methodName, $arguments)
  {
    echo "Вызван метод - " . $methodName . 'с параметрами:';
    var_dump($arguments);
  }
}
$test = new Test();
$test->someMethod(123, 234, 345); //аналогично __call('someMethod', 1



/*__CALLSTATIC($NAME, $ARGUMENTS)
__callStatic вызывается для недоступных статических методов, первый
аргумент - название метода, а второй - массив аргументов*/
class TestClass {
  public static function __callStatic($methodName, $arguments
  {
    echo "Вызван статический метод - " . $methodName;
    var_dump($arguments);
  }
}
//аналогично __callStatic('someMethod', [123, 234, 345])
Test::someMethod(123, 234, 345);



/*__CALLSTATIC И __CALL
1. __callStatic должен быть объявлен как статический метод
2. __callStatic вызывается, если мы обращаемся к методу класса
3. __call вызывается, если мы обращаемся к методу объекта
4. Все они должны быть объявлены, как public
5. Первый аргумент - всегда строка, с названием метода к которому
обращаемся
6. Существующие публичные методы не вызывают срабатывания этих
методов*/


/*РЕЗЮМЕ ПО МАГИЧЕСКИМ МЕТОДАМ
Для чего это может быть нужно? На самом деле в простых системах
потребности в этих методах немного.
Обычно подобные конструкции активно применяются во фреймворках
либо для интересных и специфичных задач, когда нужно определенным
образом организовать взаимодействие классов и объектов.
На данном этапе попробуйте осознать те возможности, что это даёт.
Фактически, вы можете перехватывать определенные события и
обрабатывать их как душе угодно*/
