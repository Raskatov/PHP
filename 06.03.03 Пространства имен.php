<?php

// ПРОСТРАНСТВА ИМЁН

/*ПРОСТРАНСТВА ИМЁН
А теперь рассмотрим иную проблему. Допустим у нас в проекте
используются две библиотеки от разных разработчиков. При этом
каждая библиотека содержит следующие классы:
— Cache - используется для кэширования
— Log - используется для логирования
— Conf - для конфигурации
И у нас написаны автозагрузчики для каждой библиотеки
$conf = new Conf(); // какой из Conf будет вызыван?
// как вызвать конкретно второй?*/




/*ПРОСТРАНСТВА ИМЁН (Ч.2)
Для этой цели в php существуют пространства имён. Они позволяют задать
свои собственные области видимости для классов и функций и назвать их
как угодно.*/
//допустим, файл \core\Test.php
namespace Core;
class Test {}




// ПРОСТРАНСТВА ИМЁН (Ч.3)
//допустим, файл \libs\Test.php
namespace Libs;
class Test {}




/*ПРОСТРАНСТВА ИМЁН (Ч.4)
Теперь, мы можем обратиться к каждому конкретному классу следующим
образом:*/
$test1 = new \Core\Test(); // myAutoloader('\Core\Test');
$test2 = new \Libs\Test(); // myAutoloader('\Libs\Test');
/*Правда теперь наши функции автозагрузки нуждаются в переработке.
Дело в том, что к ним будет приходить не только имя класса, но и всё
пространство имён для него.*/




// ВЕРНЁМСЯ К АВТОЗАГРУЗКЕ
function myAutoload($classNameWithNamespace)
{
  //учитываем пространство имён
  $pathToFile = $_SERVER['DOCUMENT_ROOT'] //ищем файлы начиная 
    . str_replace('\\', DIRECTORY_SEPARATOR, $classNameWithNameSpace
    . '.php'; //добавляем расширение
  if (file_exists($pathToFile)) {
    include "$pathToFile";
  }
  //Данная функция будет работать, если namespace дублирует 1
}




/*ПРОСТРАНСТВА ИМЁН (Ч.5)
— Пространства имён актуальны также для констант и функций (т.е. они
также могут находиться в своём пространстве имён)
— Если пространство имён не указано, то класс / константа / функция
принаддежат глобальному пространству имён*/




// ПРОСТРАНСТВА ИМЁН (Ч.6)
namespace MyProject;
// всё это принадлежит пространству имён
const MY_CONST = 10; //не define() !
function myFunction() {}
class MyClass {};





/*ПРОСТРАНСТВА ИМЁН (Ч.7)
Таким образом, если указано пространство имён в файле, всё его
содержимое, кроме переменных, содержится в нем.*/
echo \MyProject\MY_CONST;
\MyProject\myFunction();
echo \MyProject\MyClass::class; //выведет имя класса
/*Заметьте, что мы начинаем с символа \ - это означает, что мы ищем,
начиная с корневого пространства имён.*/






/*ПРОСТРАНСТВА ИМЁН (Ч.8)
На самом деле пространство имён ничем не ограничено, оно может быть и
таким:*/

//подпространства имён
namespace MyProject\Long\MyNamespace;

// Поэтому, что произойдёт, если мы будем обращаться к классу не от корня?
namespace MyProject;
$test = Long\MyNamespace\Test();
// == \MyProject\Long\MyNamespace\Test();






/*ПРОСТРАНСТВА ИМЁН (Ч.9)
Если у нас есть два класса, в одном пространстве имён, нам не нужно
писать полный путь до него.
Допустим у нас есть первый файл*/

namespace MyProject;
class TestClass1 {};

// И второй файл
namespace MyProject;
class TestClass2 {};





/*ПРОСТРАНСТВА ИМЁН (Ч.10)
Чтобы обратиться к классу из первого файла, достаточно указать его имя,
т.к. пространство имён будет автоматически подставлено.*/
namespace MyProject;
class TestClass2 {
  public $object;
  public function __construct()
  {
    $this->object = new TestClass1();
    // == \MyProject\TestClass1(); - потому что указан namespace
  }
};




/*НЕКОТОРЫЕ ВЫВОДЫ
— Поэтому мы можем, разрабатывая конкретный модуль в одном
пространстве имён, спокойно оперировать только названиями классов
— Это также решает вопрос с пересечениями названий классов
— При этом, если нам нужно вызвать один конкретный класс - мы всегда
можем указать полный путь к нему
— По простому: старайтесь всегда указывать namespace'ы по аналогии с
каталогами, в которых у вас лежат классы - для среднего проекта этого
более чем достаточно*/
