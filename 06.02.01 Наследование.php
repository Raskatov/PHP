<?php

/*СРАЗУ К КОДУ (НАСЛЕДОВАНИЕ)
Простой пример наследования*/
class ParentClass //суперкласс
{
  //любые свойства и методы
}
class ChildClass extends ParentClass
{
  //данный класс наследует все свойства и методы ParentClass
  //+ может определять свои свойства и методы
}


// ПРО УТОК (КОД)
class Bird //суперкласс
{
  public $color = 'black'; //предположим, что большинство птиц
  public function fly() { echo 'Я летаю'; }
}
  class Duck extends Bird
{
  //наследует все свойства и методы Bird
}
$duck = new Duck();
$duck->fly(); //выдаст ‘Я летаю’


/*ПРО АЛЬБИНОСОВ, МНОЖЕСТВЕННОЕ
НАСЛЕДОВАНИЕ И СУПЕРКЛАССЫ
Плохая новость: в PHP нет множественного наследования. Наследовать
свойства и методы можно только от одного класса.
Хорошая новость: НО. Цепочка наследуемых классов может быть сколь
угодно длинной.
Далее рассмотрим на альбиносах*/

// ПРО АЛЬБИНОСОВ (КОД) - Ч.1
class Bird //
{
  public $sound; //пока никакого звука
  public function fly()
  {
    echo 'Я летаю';
  }
  public function makeSomeSound()
  {
    echo 'Я издаю звук ' . $this->sound;
  }
}

// ПРО АЛЬБИНОСОВ (КОД) - Ч.2
class Duck extends Bird
{
  public $sound = “Кря”; // + наследует все свойства и методы
}
class AlbinoDuck extends Duck
{
  //наследует все свойства Duck + Bird
}
$duck = new Duck();
$duck->makeSomeSound(); // обычная утка говорит “Кря”
$albinoDuck = new AlbinoDuck();
$albinoDuck->makeSomeSound(); // Утка-альбинос тоже крякает

/*КАК - ПОНЯТНО. А НАФИГА?
— Мы можем выделить общие свойства у наших объектов, вынести их в
отдельный тип.
— Если у объектов есть общее поведение, мы избегаем дублирования кода.
Делаем его более читаемым и понятным.
— В самом простом случае мы можем описать общие моменты в
суперклассе, а в остальных классах описывать только специфическую
логику.*/







/*ПЕРЕГРУЗКА МЕТОДОВ
Важным моментом является возможность создать уникальное поведение.
Предположим, наш альбинос отличается не только цветом, но и издаёт
иные звуки. Мы можем перегрузить свойства и методы родителя.*/

// ПЕРЕГРУЗКА МЕТОДОВ (КОД) - Ч.1
class Bird //суперкласс
{
  public $sound; //пока никакого звука
  public $color; //добавили новое свойство - цвет
  public function fly() { echo 'Я летаю'; }
  public function makeSomeSound()
  {
    echo 'Я издаю звук ' . $this->sound;
  }
}


// ПЕРЕГРУЗКА МЕТОДОВ (КОД) - Ч.2
//класс перегружает свойство $sound
class Duck extends Bird { public $sound = “Кря” }
class AlbinoDuck extends Duck //наследует Duck + Bird
{
  public $color = “white”; //перегружаем свойство
  public function makeSomeSound() //перегружаем метод
  {
    echo “Нет времени объяснять! Я говорю мяу!”;
  }
}


// ПЕРЕГРУЗКА МЕТОДОВ (КОД) - Ч.3
$duck = new Duck();
$duck->makeSomeSound(); // обычная утка говорит “Кря”
$albinoDuck = new AlbinoDuck();
// Утка-альбинос не только отличается цветом, но и говорит мяу
$albinoDuck->makeSomeSound(); //... и ей нет времени объяснять







/*БЛА-БЛА-БЛА, А ЕСЛИ НЕ НА УТКАХ?
Задача: Предположим, мы хотим работать с товарами интернет-магазина
через объекты. В самом простом виде, для начала, мы хотим, чтобы у
товара было несколько свойств - название, цена. Для этого создаём
простой класс:
Попробуем решить задачу двумя способами - без наследования и с
наследованием.
Изначально решаем без наследования.*/

А ЕСЛИ НЕ НА УТКАХ? (КОД)
class Product
{
  public $price; //цена
  public $title; //название

  public function __construct($title, $price)
  {
    $this->title = $title;
    $this->price = $price;
  }
}


/*УСЛОЖНЯЕМ ЗАДАЧУ
Задача (продолжение): Мы создали общую структуру. Теперь
предположим, что наш магазин торгует книгами и важным свойствами
являются количество страниц и автор книги. Предположим, что в
дальнейшем, мы захотим вывести их в описании
Мы пока не знаем, что такое наследование. Нам нужно расширить
имеющийся класс. Заодно, можем его переименовать.*/
// УСЛОЖНЯЕМ ЗАДАЧУ (КОД)
class Book
{
public $price;
public $title;
public $pages;
public $author;

public function __construct($title, $price, $author,
  {
    //присваиваем соответствующие свойства
  }
}

/*НО И ЭТО НЕ ВСЁ
Задача (продолжение): Всё вроде пока неплохо, верно? И зачем только
придумали это дурацкое наследование. Но теперь владелец магазина
решил, что книги нынче не в моде. И нужно расширять ассортимент. Начать
решил с чего-то простого. Например, с флэшек (почему бы и нет?). У них
вообще нет параметров страниц. Зато важным является объём памяти.
Что же, добавляем новый класс для флэш-накопителей. (а куда деваться?)
22*/

// НО И ЭТО НЕ ВСЁ (КОД)
class Flash
{
  public $price;
  public $title;
  public $memory;

  public function __construct($title, $price, $memory)
  {
    $this->title = $title;
    $this->price = $price;
    $this->memory = $memory
  }
}

/*НЕ ТОМИ! ГДЕ НАСЛЕДОВАНИЕ?
Задача (продолжение): Но и тут нет веских причин что-то наследовать. Но
тут выясняется, что мы забыли одну деталь. В обоих случаях нам нужно
отдельно вывести цену и отдельно вывести название товара. Т.е. добавить
пару методов в пару классов*/

НЕ ТОМИ! ГДЕ НАСЛЕДОВАНИЕ? (КОД)
class Flash
{
  //тут все методы и свойства с предыдущего примера
  public function getTitle()
  {
    return $this->title;
  }
  public function getPrice()
  {
    return $this->price;
  }
}

/*А ПОЧЕМУ БЫ И НЕ ДА?
Аналогичный код мы добавим в класс Book. А теперь давайте
порассуждаем.
— Что нужно сделать, если мы решим торговать ещё каким-то товаром?
— Что если мы захотим изменить метод title?
— Есть ли дублирование кода? Удобно ли это?
— Как нам может помочь наследование?*/

/*НАСЛЕДОВАНИЕ: ВОЗВРАЩЕНИЕ
Хорошо, попробуем улучшить наш код. Возвращаемся к первому варианту
и немного расширим его. Для начала нам нужен общий суперкласс
Product, который будет содержать свойства и методы, общие для всех
товаров.
Обращаю внимание - общие для всех товаров. Т.е. если в будущем нам
понадобятся иные расширения для наших частных товаров, мы будем
расширять именно этот класс, а дочерние классы будут автоматически
подхватывать эти свойства.*/

// НАСЛЕДОВАНИЕ (КОД)
class Product
{
  public $price; // цена есть у любого товара
  public $title; // название - тоже
  public function __construct($title, $price) { //присваиваем public function getPrice()
  {
    return $this->price;
  }
  public function getTitle() { return $this->title; }
}

/*ВОПРОСЫ К РОДИТЕЛЮ
Ни у кого не возникло вопросов к родителю? Раньше, мы через
конструктор передавали все соответствующие параметры товара, а теперь
только цену и название.
На самом деле это даже хорошо и правильно. Мы не будем перегружать
конструктор, а воспользуемся геттерами и сеттерами.
А заодно получим порцию небольшого синтаксического сахара :)*/

ВОПРОСЫ К РОДИТЕЛЮ
class Book extends Product //наследуем
{
  //все свойства и методы Product уже есть
  //мы описываем только уникальные особенности
  public $author;
  public $pages;
  public setYear($year)
  {
    $this->year = $year;
    return $this; //магия, о которой мы поговорим чуть ниже
  }
}

/*RETURN $THIS ???
Знакомимся: fluent setters. Это то, что позволяет нам писать код более
красиво. Вместо того, чтобы определять параметры в конструкторе, мы
можем задавать свойства книги чуть иначе*/

// ОБЫЧНЫЕ СЕТТЕРЫ
//предположим мы определили сеттеры для каждого свойства
$book = new Book('Мастер и Маргарита', 500);
$book->setAuthor('Михаил Булгаков');
$book->setYear(2015); //дата выпуска
$book->setPages(200);
//любые другие свойства мы будем задавать отдельно в каждой


/*FLUENT SETTERS */

//предположим мы определили сеттеры для каждого свойства
$book = new Book('Мастер и Маргарита', 500);
$book->setAuthor('Михаил Булгаков')->setYear(2015)->setPages

//или (идентично)
$book->setAuthor('Михаил Булгаков')
  ->setYear(2015)
  ->setPages(200);
// Этим можно пользоваться не только для сеттеров.





/*ВЕРНЕМСЯ К КНИГАМ
Ввиду того, что кода вмещается мало на один слайд, перейдем к реалтайм
кодингу.
Попробуем решить нашу задачу в реальном времени и получить полную
картину. Заодно дополним нашу задачу. Для рассчета стоимости доставки
нам понадобился вес. Попробуем решить, куда мы его будем добавлять и
добавим метод для рассчета доставки.
Если вы вдруг читаете этот слайд и хотите посмотреть, что было дальше -
добро пожаловать в видео %)*/
