<?php

//ОБЛАСТЬ ВИДИМОСТИ СВОЙСТВ И МЕТОДОВ
/*ОБЛАСТИ ВИДИМОСТИ
Из того, что мы уже использовали, остался один вопрос - что же такое
public?
В рамках класса свойства и методы могут иметь свою область видимости,
которая определяет, как работать с этими свойствами
1. private
2. protected
3. public*/

/*PUBLIC
Public-свойства и методы, это как раз те свойства и методы, к которым мы
можем обратиться в программе напрямую*/
class SimpleClass
{
  public $publicProperty; // публичное свойство
  //публичный метод
  public function publicMethod() {}
}

/*PUBLIC - КАК РАБОТАТЬ
И всё круто.*/
$object = new SimpleClass();
//вызываем публичный метод
$object->publicMethod();
//задаем публичное свойство
$object->publicProperty = 100;
//выводим значение публичного свойства
echo $object->publicProperty;





/*PRIVATE И PROTECTED
Принципиальная разница между private и protected будет понятна на
следующей лекции (наследование)
Private свойства принадлежат только классу, в котором были определены
Protected - принадлежат классу и наследникам
Не вдаваясь в детали, в обоих случаях к таким свойствам и методам
нельзя обратиться напрямую.*/

PRIVATE И PROTECTED
class SimpleClass
{
  public $publicProperty; // публичное свойство
  private $privateProperty; // приватное свойство
  protected $protectedProperty; // защищенное свойство

  public function publicMethod() {} //публичный метод
  private function privateMethod() {} // приватный метод
  protected function protectedMethod() {} //защищенный метод
}

/*PRIVATE И PROTECTED (Ч.2)*/
$object = new SimpleClass(); //создали объект
$object->publicProperty = 100; // ок - изменили публичное свойство 
echo $object->publicProperty; // ок - вывели публичное свойство 
$object->publicMethod(); // ок - обратились к публичному методу 

$object->privateProperty = 100; //ошибка нельзя менять приватное 
echo $object->privateProperty; //ошибка даже получить его нельзя
$object->protectedProperty = 100; //ошибка нельзя менять защищенное 
echo $object->protectedProperty; //ошибка вывести его тоже нельзя
$object->privateMethod(); //ошибка нельзя обратиться к приватному 
$object->protectedMethod(); //ошибка нельзя обратиться к защищенному ошибка

/*КАК РАБОТАТЬ С PRIVATE И PROTECTED
При этом данные свойства недоступны только для обращения извне.
Внутри методов, например, мы всё также имеем возможность их изменять
(через $this)*/
class SimpleClass
{
  private $privateProperty = 100;

  public publicMethod($value)
  {
    $this->privateProperty = $value; //всё ок
  }
}


КАК РАБОТАТЬ С PRIVATE И PROTECTED (Ч.2)
$object = new SimpleClass();
//тут через публичный метод мы присвоим значение
//приватному свойству
$object->publicMethod(200);
/*Что? Почему? Потому что мы работаем в рамках одного контекста. А
private и protected - защита от обращения вне его.
Поэтому легко можно определить публичные методы, которые будут
отдавать приватные свойства.*/

// ПРИМЕР
class SimpleClass
{
  private $privateProperty = 100;

  //их ещё называют геттерами
  public getPrivateProperty()
  {
    return $this->privateProperty;
  }
}

/*ЭМ. А РАВЗЕ ЭТО НЕ ДЫРКА В
БЕЗОПАСНОСТИ?
Отчасти. Но:
1. Мы сами решаем для каких свойств предусматривать геттеры и сеттеры,
а для каких нет. Что-то может остаться "внутренней кухней".
2. Мы можем предусмотреть дополнительную логику при обращении
(например, логировать или считать сколько раз обратились к какому
свойству)
3. Иными словами - мы имеем больше контроля, рамки которого
определяем сами. В случае с публичными свойствами у нас контроля нет
вообще. Любой в любом месте программы может их получать и менять.*/

/*НА НАШЕМ ПРИМЕРЕ
В нашем случае логично использовать private для свойства цена. При этом
мы должны иметь возможность разово её задать и всё.*/
class Product
{
  private $price;
  //тут свойства name, discount, category
  public function __construct($name, $price, $discount
  {
    $this->name = $name;
    $this->price = $price //задали значение приватному свойству
    $this->discount = $discount;
  }
}

/*НА НАШЕМ ПРИМЕРЕ (Ч.2)
В нашем случае логично использовать private для свойства цена. При этом
мы должны иметь возможность разово её задать и всё.
*/
$iphone = new Product('Apple iPhone 7', 50000);
$iphone->price = 0; //ошибка - не надо так
echo $iphone->price; //ошибка - атата, так цену не получают
//но свойство price имеет значение (присвоено в конструкторе),
// поэтому мы легко можем вывести цену, как нам нужно
$iphone->getPrice(); //все ок и это единственный способ в нашем ошибка
