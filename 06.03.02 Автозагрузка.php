<?php

// АВТОЗАГРУЗКА
/*О ЗАГРУЗКЕ КЛАССОВ
Для того, чтобы класс можно было использовать, сперва его нужно
подключить в приложение. Самый "прямой" (но не самый простой и
правильный) путь - это вызывать для каждого класса require / include
Когда у вас 3-5 классов, это не создаёт никаких проблем. Но если вы
создаёте более-менее сложную систему, загружать через require - грусть и
печаль.
Может поменяться название файла - и в каждом месте, где класс
подключается, нужно не забыть предусмотреть эти изменения.*/



/*О ЗАГРУЗКЕ КЛАССОВ (Ч.2)
Поэтому для начала давайте примем как факт:
— Каждый класс должен находится в отдельном файле
— Классы могут находится в разных директориях
— Нам нужно сделать так, чтобы мы могли в нужный момент получить
доступ к соответствующему классу
— Названия файлов классов лучше делать в виде определенного шаблона*/



/*__AUTOLOAD($CLASSNAME)
В PHP есть магическая функция (не метод!) __autoload
— Она принимает на вход единственный параметр - строка с именем
вызываемого класса
— Как и всё магическое, она вызывается автоматически при
возникновении определенного события - попытки обращения к классу,
который ещё не был загружен
Итак, предположим, что все классы лежат в папке classes, а название
классов строится по маске *.class.php*/


// __AUTOLOAD($CLASSNAME) (Ч.2)
// $className содержит название класса, который мы вызываем
function __autoload($className) //это функция! не метод!
{
  $filePath = './classes/' . $className . '.class.php';
  if (file_exists($filePath)) {
    include "$filePath";
  } else {
    die("Класса $className не существует");
  }
}
$test = new TestClass(); // вызывается __autoload('TestClass');



/*__AUTOLOAD($CLASSNAME) (Ч.3)
У данной функции есть один недостаток. Если у нас классы могут
находиться во множестве разных директорий, то она превращается в
сборник if'ов, который затруднительно поддерживать.
В связи с этим, для решения этой проблемы существует альтернатива -
spl_autoload_register(), а данная функция является устаревшей
Поэтому не нужно её использовать :)*/



/*SPL_AUTOLOAD_REGISTER
spl_autoload_register может регистрировать любое количество функций
автозагрузчиков, которые мы создадим. Они будут вызываться
последовательно.
Как выглядит алгоритм?
1. Создаём любое количество функций, которые будем использовать для
автозагрузчиков
2. Регистрируем их через spl_autoload_register
3. Получаем счастье и радость*/




/*SPL_AUTOLOAD_REGISTER (Ч.2)
Мы можем как угодно называть наши функции автозагрузки, а первым
аргументом в них всегда будет $className*/
// $className содержит название класса, который мы вызываем
function myAutoload($className)
{
  $filePath = './classes/' . $className . '.class.php';
  if (file_exists($filePath)) {
    include "$filePath";
  }
  //заметьте, die мы убрали, т.к. предполагаем, что
  //будут и иные автозагрузчики после
}


/*
SPL_AUTOLOAD_REGISTER (Ч.3)
Создадим ещё автозагрузчик*/
// $className содержит название класса, который мы вызываем
function coreAutoloader($className)
{ //прошлый искал классы в classes, этот берет из core
  $filePath = './core/' . $className . '.class.php';
  if (file_exists($filePath)) {
    include "$filePath";
  }
  //и тут без die (
}




/*SPL_AUTOLOAD_REGISTER (Ч.4)
Теперь регистрируем автозагрузчики*/
spl_autoload_register('myAutoload');
spl_autoload_register('coreAutoloader');
$test = new TestClass();
/*1. Сперва TestClass будет искаться в myAutoload - myAutoload('TestClass');
2. Затем TestClass будет искаться в coreAutoloader -
coreAutoloader('TestClass');
3. Если класс не будет нигде найден - будет fatal*/






/*SPL_AUTOLOAD_REGISTER (Ч.5)
В результате, мы можем создавать любое количество автозагрузчиков и
гибко их подключать в нужной нам последовательности. Можно даже так
регистрировать автозагрузчики без создания функций:*/
spl_autoload_register(
  function ($className) {
    include $className . '.php';
  }
);
