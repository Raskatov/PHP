<?php

// И ЕЩЕ ПРО ОБЛАСТИ ВИДИМОСТИ
/*PUBLIC
Можно получить доступ к свойству или методу отовсюду (внутри класса,
внутри родительского класса. В общем виде, мы можем изменять значения
memory для наших флэш-карт и запрашивать их и без геттеров и сеттеров
*/
$flash = new Flash(‘Флэшка’, 100);
$flash->memory = 2000;
echo $flash->memory; // выведет 2000
/*Это не совсем корректно, т.к. можно случайно изменить свойство класса, а
в нашем случае оно должно быть неизменяемым.*/



/*PRIVATE
Доступ к таким методам и свойствам возможен только внутри самого
класса. Классы, которые его наследуют, не получат доступ к данному
методу или свойству.
В случае с memory это как раз то, что нам нужно. Мы не планируем, что у
класса вообще будут наследники, а если мы и забыли ключевое слово final,
мы не дадим другим классам работать с этим свойством.*/


// PRIVATE (КОД)
final class Flash extends Product
{
  private $memory; // в данном случае мы запрещаем кому бы то 
  // к данному свойству извне

  //при этом, если мы хотим изменить свойство - есть сеттер
  public function setMemory($memory)
  {
    $this->memory = $memory;
  }
}


/*PRIVATE (КОД)
Изменение значения свойства через сеттер все равно имеет ряд
преимуществ. Например, мы можем не давать присваивать отрицательные
значения. В случае работы с public свойством напрямую, мы это
ограничить не можем.*/
$flash = new Flash(‘Флэшка’, 100);
$flash->memory = 2000; // выдаст ошибку, пытаемся изменить приватное 
$flash->setMemory = 2000; // а так можно (если мы оставялем такую 1









/*PROTECTED
Но что делать с ценой и названием товара? Если вы помните, у нас они
также объявлены, как публичные свойства. Соответственно в любом месте
кода можно обратиться к свойству напрямую и изменить его. Это может
обеспечить проблемы в будущем.
При этом мы не можем объявить их как приватные переменные. В этом
случае, наши конкретные товары не будут иметь доступ к этим свойствам.
Есть два варианта решения проблемы: Объявить эти свойства приватными,
но написать для них геттеры и сеттеры или Объявить эти свойства
защищенными (protected)*/

/*PROTECTED
Второй способ для них наиболее предпочтителен, т.к. мы можем в
будущем захотеть оперировать ценой в каждом классе по своему.
Protected не повзолит обращаться к цене напрямую
*/
$flash = new Flash(‘Флэшка’, 100);
$flash->price = 200; // выдаст ошибку, пытаемся изменить защищенное 1
/*Но! При этом мы сможем работать внутри класса flash со свойством, как
захотим. Например, мы хотим, чтобы на все флэшки действовала скидка 20
процентов.*/


// PROTECTED (КОД)
final class Flash extends Product
{
  // остальные свойства и методы
  //перегружаем геттер для получения цены конкретно для флешек
  public function getPrice()
  {
    //саму скидку по хорошему тоже вынести в свойство
    //но в какой класс?
    return round($this->price * 20 / 100)
  }
}
